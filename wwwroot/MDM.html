<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ëª¨ë¹„ë…¸ê¸° ë¯¸í„°ê¸°</title>
  <style>
    :root {
      --bg-color: #121212;
      --primary-color: #3498db;
      --secondary-color: #2c3e50;
      --accent-color: #e74c3c;
      --text-color: #ecf0f1;
      --muted-text: #7f8c8d;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
    }

    .container {
      max-width: 1200px;
      margin: auto;
      padding: 20px;
    }

    .header {
      background: var(--secondary-color);
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      text-align: center;
    }

    .header h1 {
      margin: 0;
      font-size: 2em;
      color: var(--primary-color);
    }

    .battle-info {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin-top: 10px;
      font-size: 1em;
    }

    .player-rankings {
      background-color: #1e1e1e;
      border-radius: 10px;
      padding: 20px;
    }

    .ranking-header {
      display: grid;
      grid-template-columns: 50px 1fr 150px;
      padding: 10px;
      background: var(--secondary-color);
      font-weight: bold;
      border-radius: 5px;
    }

    .player-bar {
      display: grid;
      grid-template-columns: 50px 1fr 150px;
      align-items: center;
      background: #2a2a2a;
      margin-top: 8px;
      border-radius: 5px;
      padding: 8px;
      transition: transform 0.2s ease;
    }

    .player-bar:hover {
      transform: scale(1.01);
      background: #333;
    }

    .player-name {
      font-weight: bold;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .damage-value {
      text-align: right;
    }

    .skill-breakdown {
      margin-top: 10px;
      background: #1c1c1c;
      padding: 10px;
      border-left: 4px solid var(--primary-color);
      border-radius: 5px;
    }

    .skill-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 4px 0;
      background: #2c2c2c;
      padding: 4px 10px;
      border-radius: 3px;
    }

    .log-table {
      margin-top: 10px;
      overflow-x: auto;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9em;
    }

    th, td {
      padding: 8px;
      text-align: center;
    }

    th {
      background: #333;
    }

    tr:nth-child(even) {
      background: #222;
    }

    .connection-status {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--accent-color);
      padding: 8px 14px;
      border-radius: 4px;
      font-weight: bold;
    }

    .connected {
      background: #27ae60 !important;
    }

    @media (max-width: 600px) {
      .ranking-header, .player-bar {
        grid-template-columns: 30px 1fr 80px;
      }
      .battle-info {
        flex-direction: column;
        align-items: center;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>ëª¨ë¹„ë…¸ê¸° ë¯¸í„°ê¸°</h1>
      <div class="battle-info">
        <span>ì „íˆ¬ ì‹œê°„: <span id="battle-time">0ì´ˆ</span></span>
        <span>ì´ ë°ë¯¸ì§€: <span id="total-damage">0</span></span>
        <span>RDPS: <span id="raid-dps">0</span></span>
        <span>ì°¸ì—¬ì ìˆ˜: <span id="player-count">0</span></span>
      </div>
    </div>

    <div class="connection-status" id="connection-status">ì—°ê²° ëŠê¹€</div>

    <div class="player-rankings" id="player-rankings">
      <div class="ranking-header">
        <div>#</div>
        <div>í”Œë ˆì´ì–´</div>
        <div>ë°ë¯¸ì§€</div>
      </div>
      <!-- Player bars and breakdown will be appended here -->
    </div>
  </div>

  <script>
        let ws = null;
        let battleData = {};
        const userLogFilters = {}; // userId â†’ { skillFilter, targetFilter, critOnly, addHitOnly }
        // log ì •ë ¬ ê¸°ì¤€ì„ ì €ì¥í•  ê°ì²´
        const logSortSettings = {};

        let startTime = 0;
        let lastUpdateTime = 0;
        let totalBattleDamage = 0;
        let expandedPlayers = new Set(); 
 
        const classMapping = {
            'SwordMaster': { name: 'ê²€ìˆ ', color: 'linear-gradient(90deg, #8B4513, #A0522D)' },
            'Arbalist': { name: 'ì„ê¶ì‚¬ìˆ˜', color: 'linear-gradient(90deg, #228B22, #32CD32)' },
            'FireMage': { name: 'í™”ë²•', color: 'linear-gradient(90deg, #FF4500, #FF6347)' },
            'IceMage': { name: 'ì–¼íƒ±', color: 'linear-gradient(90deg, #4169E1, #87CEEB)' },
            'Fighter': { name: 'ê²©íˆ¬ê°€', color: 'linear-gradient(90deg, #DC143C, #B22222)' },
            'LongBowMan': { name: 'ì¥ê¶ë³‘', color: 'linear-gradient(90deg, #2E8B57, #3CB371)' },
            'Healer': { name: 'íëŸ¬', color: 'linear-gradient(90deg, #FFD700, #FFA500)' },
            'ExpertWarrior': { name: 'ì „ì‚¬', color: 'linear-gradient(90deg, #696969, #808080)' },
            'GreatSwordWarrior': { name: 'ëŒ€ê²€ì „ì‚¬', color: 'linear-gradient(90deg, #4B0082, #6A5ACD)' },
            'HighThief': { name: 'ë„ì ', color: 'linear-gradient(90deg, #2F4F4F, #708090)' },
            'DualBlades': { name: 'ë“€ë¸”', color: 'linear-gradient(90deg, #8B008B, #DA70D6)' },
            'HighArcher': { name: 'ê¶ìˆ˜', color: 'linear-gradient(90deg, #006400, #228B22)' },
            'HighMage': { name: 'ë§ˆë²•ì‚¬', color: 'linear-gradient(90deg, #4B0082, #9400D3)' },
            'Priest': { name: 'ì‚¬ì œ', color: 'linear-gradient(90deg, #F0F8FF, #E6E6FA)' },
            'Bard': { name: 'ìŒìœ ì‹œì¸', color: 'linear-gradient(90deg, #FF69B4, #FFB6C1)' },
            'Monk': { name: 'ìˆ˜ë„ì‚¬', color: 'linear-gradient(90deg, #CD853F, #D2691E)' },
            'Dancer': { name: 'ëŒ„ì„œ', color: 'linear-gradient(90deg, #FF1493, #FF69B4)' },
            'BattleMusician': { name: 'ì•…ì‚¬', color: 'linear-gradient(90deg, #9932CC, #BA55D3)' }
        };
        const skipUpdateForUser = userId => {
            const active = document.activeElement;
            if (!active) return false;
            return active.id === `skill-filter-${userId}` || active.id === `target-filter-${userId}`;
        };
        function detectPlayerClass(userData) {
            if (!userData.skills) return null;
 
            for (const skillName of Object.keys(userData.skills)) {
                for (const [classCode, classInfo] of Object.entries(classMapping)) {
                    if (skillName.includes(classCode)) {
                        return classCode;
                    }
                }
            }
            return null;
        }
 
        function connectWebSocket() {
            try {
                ws = new WebSocket("ws://localhost:9001");
 
                ws.onopen = function(evt) {
                    console.log("ì›¹ì†Œì¼“ ì—°ê²°ë¨");
                    updateConnectionStatus(true);
                };
 
                ws.onclose = function(evt) {
                    console.log("ì›¹ì†Œì¼“ ì—°ê²° í•´ì œë¨");
                    updateConnectionStatus(false);
                    setTimeout(connectWebSocket, 3000);
                };
 
                ws.onmessage = function(evt) {
                    processDamageData(evt.data);
                };
 
                ws.onerror = function(evt) {
                    console.error("ì›¹ì†Œì¼“ ì˜¤ë¥˜:", evt);
                    updateConnectionStatus(false);
                };
            } catch (error) {
                console.error("ì›¹ì†Œì¼“ ì—°ê²° ì‹¤íŒ¨:", error);
                updateConnectionStatus(false);
                setTimeout(connectWebSocket, 3000);
            }
        }
 
        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connection-status');
            if (connected) {
                statusElement.textContent = 'ì—°ê²°ë¨';
                statusElement.className = 'connection-status connected';
            } else {
                statusElement.textContent = 'ì—°ê²° ëŠê¹€';
                statusElement.className = 'connection-status disconnected';
            }
        }
 
        function processDamageData(data) {
            const parts = data.split('|');
            //if (parts.length !== 16) return;
 
            const timestamp = parseInt(parts[0]);
            const userId = parts[1];
            const target = parts[2];
            const skill = parts[3];
            const skillId = parts[4]; // skillId is not used but kept for compatibility
            const damage = parseInt(parts[5]);
            const critFlag = parseInt(parts[6]);
            const addHitFlag = parseInt(parts[7]);
            const dotFlag = parseInt(parts[8]);
            const iceFlag = parseInt(parts[9]);
            const fireFlag = parseInt(parts[10]);
            const electricFlag = parseInt(parts[11]);
            const holyFlag = parseInt(parts[12]);
            const bleedFlag = parseInt(parts[13]);
            const poisonFlag = parseInt(parts[14]);
            const mindFlag = parseInt(parts[15]);

            if (lastUpdateTime === 0 || timestamp - lastUpdateTime > 10000) {
                startNewBattle(timestamp);
            }
 
            lastUpdateTime = timestamp;
 
            // Initialize user data if needed
            if (!battleData[userId]) {
                battleData[userId] = {
                    totalDamage: 0,
                    damageLogs: [],
                    damageByTarget: {}, // MODIFIED: Track damage per target
                    hitCount: 0,
                    critCount: 0,
                    addHitCount: 0,
                    skills: {}
                };
            }
 
            // Initialize target-specific damage if needed
            if (!battleData[userId].damageByTarget[target]) {
                battleData[userId].damageByTarget[target] = 0;
            }
 
            // Initialize skill data if needed
            if (!battleData[userId].skills[skill]) {
                battleData[userId].skills[skill] = {
                    damage: 0,
                    hits: 0,
                    crits: 0,
                    addHits: 0
                };
            }
 
            // Update data
            battleData[userId].totalDamage += damage;
            battleData[userId].damageByTarget[target] += damage; // MODIFIED: Add damage to specific target
            battleData[userId].skills[skill].damage += damage; // Keep total skill damage for breakdown
 
            if (!addHitFlag) {
                battleData[userId].hitCount += 1;
                battleData[userId].skills[skill].hits += 1;
            }
 
            if (critFlag) {
                battleData[userId].critCount += 1;
                battleData[userId].skills[skill].crits += 1;
            }
 
            if (addHitFlag) {
                battleData[userId].addHitCount += 1;
                battleData[userId].skills[skill].addHits += 1;
            }
 
            totalBattleDamage += damage;
            battleData[userId].damageLogs ??= [];
            battleData[userId].damageLogs.push({
                timestamp,
                target,
                skill,
                damage,
                crit: critFlag,
                addHit: addHitFlag,
                dot: dotFlag,
                ice: iceFlag,
                fire: fireFlag,
                electric: electricFlag,
                holy: holyFlag,
                bleed: bleedFlag,
                poison: poisonFlag,
                mind: mindFlag
            });
        }
 
        function startNewBattle(timestamp) {
            console.log("ìƒˆë¡œìš´ ì „íˆ¬ ì‹œì‘");
            battleData = {};
            startTime = timestamp;
            totalBattleDamage = 0;
            expandedPlayers.clear();
            updateDisplay();
        }
 
        function updateBattleInfo() {
            const battleTime = lastUpdateTime > 0 ? Math.floor((lastUpdateTime - startTime) / 1000) : 0;
            const playerCount = Object.values(battleData).filter(ud => detectPlayerClass(ud)).length;
 
            let raidDps = 0;
            if (battleTime > 0) {
                raidDps = Math.floor(totalBattleDamage / battleTime);
            }
 
            document.getElementById('battle-time').textContent = `${battleTime}ì´ˆ`;
            document.getElementById('total-damage').textContent = totalBattleDamage.toLocaleString();
            document.getElementById('raid-dps').textContent = raidDps.toLocaleString();
            document.getElementById('player-count').textContent = playerCount;
        }
 
function updatePlayerRankings() {
  const container = document.getElementById('player-rankings');
  if (Object.keys(battleData).length === 0) {
    container.innerHTML = `<div class="ranking-header"><div>ìˆœìœ„</div><div>í”Œë ˆì´ì–´</div><div>ë°ë¯¸ì§€ (DPS)</div></div><div class="no-data">ë°ë¯¸ì§€ ë°ì´í„°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...</div>`;
    return;
  }

  // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ì €ì¥
  const scrollTop = container.scrollTop;

  const sortedPlayers = Object.entries(battleData).sort(([, a], [, b]) => b.totalDamage - a.totalDamage);
  const maxDamage = sortedPlayers.length > 0 ? sortedPlayers[0][1].totalDamage : 1;
  const battleTime = lastUpdateTime > 0 ? Math.max(1, (lastUpdateTime - startTime) / 1000) : 1;

  let html = `<div class="ranking-header"><div>ìˆœìœ„</div><div>í”Œë ˆì´ì–´</div><div>ë°ë¯¸ì§€ (DPS)</div></div>`;
  let displayedPlayerIndex = 0;

  sortedPlayers.forEach(([userId, userData]) => {
    const detectedClass = detectPlayerClass(userData);
    if (!detectedClass || !classMapping[detectedClass]) return;

    if (skipUpdateForUser(userId)) return;

    const targetDamages = Object.values(userData.damageByTarget);
    const mainTargetDamage = targetDamages.length > 0 ? Math.max(...targetDamages) : 0;
    const otherTargetsDamage = userData.totalDamage - mainTargetDamage;
    const mainDamagePercent = userData.totalDamage > 0 ? (mainTargetDamage / userData.totalDamage) * 100 : 0;
    const otherDamagePercent = 100 - mainDamagePercent;
    const playerDps = Math.floor(userData.totalDamage / battleTime);
    const barWidth = (userData.totalDamage / maxDamage) * 100;
    const barColor = classMapping[detectedClass].color;
    const className = classMapping[detectedClass].name;
    const rankClass = displayedPlayerIndex < 3 ? `rank-${displayedPlayerIndex + 1}` : '';
    const displayName = `${className} ${userId.substring(0, 8)}`;

    html += `
      <div class="player-bar" onclick="toggleSkillBreakdown('${userId}')">
        <div class="player-bar-fill-wrapper" style="width: ${barWidth}%;">
          <div class="damage-segment main-target-damage" style="width: ${mainDamagePercent}%; background: ${barColor};"></div>
          <div class="damage-segment other-targets-damage" style="width: ${otherDamagePercent}%; background: ${barColor};"></div>
        </div>
        <div class="player-bar-content">
          <div class="rank-section">
            <div class="rank-number ${rankClass}">${displayedPlayerIndex + 1}</div>
          </div>
          <div class="player-name">
            ${displayName}
          </div>
          <div class="stat-value damage-value">
            ${mainTargetDamage.toLocaleString()}<span class="plus-sign">+</span>${otherTargetsDamage.toLocaleString()}<span class="total-dps">(${playerDps.toLocaleString()})</span>
          </div>
        </div>
      </div>
      <div class="skill-breakdown ${expandedPlayers.has(userId) ? 'show' : ''}" id="skills-${userId}">
        ${generateSkillBreakdown(userId, userData, userLogFilters[userId] || {})}
      </div>
    `;
    displayedPlayerIndex++;
  });

  if (displayedPlayerIndex === 0) {
    html += `<div class="no-data">ê°ì§€ëœ í”Œë ˆì´ì–´ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>`;
  }

  container.innerHTML = html;

  // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë³µì›
  container.scrollTop = scrollTop;
}
        function toggleLogSort(userId, column) {
            if (!logSortSettings[userId]) {
                logSortSettings[userId] = { column: column, ascending: true };
            } else {
                const current = logSortSettings[userId];
                if (current.column === column) {
                    current.ascending = !current.ascending;
                } else {
                    current.column = column;
                    current.ascending = true;
                }
            }
            filterAndRenderLogs(userId);
        }
        function filterAndRenderLogs(userId) {
            const skillFilter = document.getElementById(`skill-filter-${userId}`)?.value || '';
            const targetFilter = document.getElementById(`target-filter-${userId}`)?.value || '';
            const critOnly = document.getElementById(`crit-filter-${userId}`)?.checked || false;
            const addHitOnly = document.getElementById(`addhit-filter-${userId}`)?.checked || false;


            // ìƒíƒœ ì €ì¥
            userLogFilters[userId] = { skillFilter, targetFilter, critOnly, addHitOnly };

            const filtered = applyLogFilter(userId, skillFilter, targetFilter, critOnly, addHitOnly);
            document.getElementById(`log-table-${userId}`).innerHTML = generateLogTable(userId, filtered);
        }
        function applyLogFilter(userId, skillFilter, targetFilter, critOnly, addHitOnly) {
            const originalLogs = battleData[userId]?.damageLogs ?? [];
            const skillLower = skillFilter.toLowerCase();
            const targetLower = targetFilter.toLowerCase();

            return originalLogs.filter(log =>
                (!skillFilter || log.skill.toLowerCase().includes(skillLower)) &&
                (!targetFilter || log.target.toLowerCase().includes(targetLower)) &&
                (!critOnly || log.crit) &&
                (!addHitOnly || log.addHit)
            );
        }        
        function generateSkillStats(userId, userData) {
            if (!userData.skills || Object.keys(userData.skills).length === 0) {
                return '<div style="color: #7f8c8d; text-align: center;">ìŠ¤í‚¬ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</div>';
            }

            const sortedSkills = Object.entries(userData.skills).sort(([, a], [, b]) => b.damage - a.damage);
            const maxSkillDamage = sortedSkills.length > 0 ? sortedSkills[0][1].damage : 1;

            let html = `<div class="skill-breakdown-header">ìœ ì € ${userId.substring(0, 8)} - ìŠ¤í‚¬ ìƒì„¸ (ì „ì²´ íƒ€ê²Ÿ í•©ì‚°)</div>`;

            sortedSkills.forEach(([skillName, skillData]) => {
                const skillPercentage = userData.totalDamage > 0 ? ((skillData.damage / userData.totalDamage) * 100).toFixed(1) : 0;
                const skillTotalHits = skillData.hits + skillData.addHits;
                const skillCritRate = skillTotalHits > 0 ? ((skillData.crits / skillTotalHits) * 100).toFixed(1) : 0;
                const barWidth = (skillData.damage / maxSkillDamage) * 100;

                html += `
                    <div class="skill-item">
                        <div class="skill-item-fill" style="width: ${barWidth}%">
                            <div class="skill-item-info">${skillName}</div>
                        </div>
                        <div class="skill-item-stats">
                            íƒ€ìˆ˜ ${skillData.hits} | í¬ë¦¬ ${skillCritRate}% | ì¶”ê°€íƒ€ìœ¨ ${skillData.hits > 0 ? ((skillData.addHits / skillData.hits) * 100).toFixed(1) : 0}% | ${skillData.damage.toLocaleString()} (${skillPercentage}%)
                        </div>
                    </div>
                `;
            });

            return html;
        }

        function generateLogTable(userId, logs) {
            if (!logs || logs.length === 0) return '<div style="color:#888; text-align:center;">ë°ë¯¸ì§€ ë¡œê·¸ ì—†ìŒ</div>';

            // ì •ë ¬ ì ìš©
            const sort = logSortSettings[userId];
            if (sort) {
                const key = sort.column;
                logs.sort((a, b) => {
                    const aVal = a[key];
                    const bVal = b[key];
                    if (typeof aVal === 'number' && typeof bVal === 'number') {
                        return sort.ascending ? aVal - bVal : bVal - aVal;
                    } else {
                        return sort.ascending
                            ? String(aVal).localeCompare(String(bVal))
                            : String(bVal).localeCompare(String(aVal));
                    }
                });
            }

            let html = `<div style="max-height:200px; overflow-y:auto; font-size:0.85em; background:#2c2c2c; border-radius:4px;">
                <table style="width:100%; border-collapse:collapse;">
                    <thead>
                        <tr style="background:#3a3a3a; cursor: pointer;">
                            <th onclick="toggleLogSort('${userId}', 'timestamp')">ì‹œê°„</th>
                            <th onclick="toggleLogSort('${userId}', 'skill')">ìŠ¤í‚¬</th>
                            <th onclick="toggleLogSort('${userId}', 'target')">ëŒ€ìƒ</th>
                            <th onclick="toggleLogSort('${userId}', 'damage')">ë°ë¯¸ì§€</th>
                            <th onclick="toggleLogSort('${userId}', 'crit')">í¬ë¦¬</th>
                            <th onclick="toggleLogSort('${userId}', 'addHit')">ì¶”íƒ€</th>
                            <th onclick="toggleLogSort('${userId}', 'dot')">DOT</th>
                            <th onclick="toggleLogSort('${userId}', 'ice')">ì–¼ìŒ</th>
                            <th onclick="toggleLogSort('${userId}', 'fire')">ë¶ˆ</th>
                            <th onclick="toggleLogSort('${userId}', 'electric')">ì „ê¸°</th>
                            <th onclick="toggleLogSort('${userId}', 'holy')">ì‹ ì„±</th>
                            <th onclick="toggleLogSort('${userId}', 'bleed')">ì¶œí˜ˆ</th>
                            <th onclick="toggleLogSort('${userId}', 'poison')">ë…</th>
                            <th onclick="toggleLogSort('${userId}', 'mind')">ì •ì‹ </th>
                        </tr>
                    </thead><tbody>`;

            logs.slice(-100).reverse().forEach(log => {
                const date = new Date(log.timestamp).toLocaleTimeString('ko-KR', { hour12: false });
                html += `<tr style="text-align:center; border-top:1px solid #444;">
                    <td>${date}</td>
                    <td>${log.skill}</td>
                    <td>${log.target}</td>
                    <td>${log.damage.toLocaleString()}</td>
                    <td>${log.crit ? 'âœ…' : ''}</td>
                    <td>${log.addHit ? 'â•' : ''}</td>
                    <td>${log.dot ? 'â—' : ''}</td>
                    <td>${log.ice ? 'â„ï¸' : ''}</td>
                    <td>${log.fire ? 'ğŸ”¥' : ''}</td>
                    <td>${log.electric ? 'âš¡' : ''}</td>
                    <td>${log.holy ? 'âœï¸' : ''}</td>
                    <td>${log.bleed ? 'ğŸ©¸' : ''}</td>
                    <td>${log.poison ? 'â˜ ï¸' : ''}</td>
                    <td>${log.mind ? 'ğŸ§ ' : ''}</td>
                </tr>`;
            });

            html += `</tbody></table></div>`;
            return html;
        }

        function generateSkillBreakdown(userId, userData, filters = {}) {
            const {
                skillFilter = '',
                targetFilter = '',
                critOnly = false,
                addHitOnly = false
            } = filters;

            const logFiltered = applyLogFilter(userId, skillFilter, targetFilter, critOnly, addHitOnly);

            return `
                <div id="skill-stat-${userId}">
                    ${generateSkillStats(userId, userData)}
                </div>
                <div style="margin-top:20px; font-weight:bold; color:#3498db;">ğŸ“œ ë°ë¯¸ì§€ ë¡œê·¸</div>
                <div style="margin-bottom:10px; display:flex; gap:10px; flex-wrap:wrap;">
                    <input type="text" id="skill-filter-${userId}" placeholder="ìŠ¤í‚¬ëª… í•„í„°" value="${skillFilter}" oninput="filterAndRenderLogs('${userId}')">
                    <input type="text" id="target-filter-${userId}" placeholder="ëŒ€ìƒ í•„í„°" value="${targetFilter}" oninput="filterAndRenderLogs('${userId}')">
                    <label><input type="checkbox" id="crit-filter-${userId}" ${critOnly ? 'checked' : ''} onchange="filterAndRenderLogs('${userId}')"> í¬ë¦¬ë§Œ</label>
                    <label><input type="checkbox" id="addhit-filter-${userId}" ${addHitOnly ? 'checked' : ''} onchange="filterAndRenderLogs('${userId}')"> ì¶”ê°€íƒ€ë§Œ</label>
                    
                </div>
                <div id="log-table-${userId}">${generateLogTable(userId, logFiltered)}</div>
            `;
        }

        function toggleSkillBreakdown(userId) {
            const skillBreakdown = document.getElementById(`skills-${userId}`);
            if (!skillBreakdown) return;
 
            if (expandedPlayers.has(userId)) {
                expandedPlayers.delete(userId);
                skillBreakdown.classList.remove('show');
            } else {
                // Collapse others first for single-expansion mode
                document.querySelectorAll('.skill-breakdown.show').forEach(el => el.classList.remove('show'));
                expandedPlayers.clear();
                
                expandedPlayers.add(userId);
                // Update content before showing to ensure it's fresh
                const userData = battleData[userId];
                if (userData) {
                    const filters = userLogFilters[userId] || { skillFilter: '', targetFilter: '', critOnly: false, addHitOnly: false };
                    skillBreakdown.innerHTML = generateSkillBreakdown(userId, userData, filters);
                }
                skillBreakdown.classList.add('show', 'animate');
                setTimeout(() => skillBreakdown.classList.remove('animate'), 300);
            }
        }
                // CSV ë‹¤ìš´ë¡œë“œ ë²„íŠ¼ ì¶”ê°€ í•¨ìˆ˜
        function addExportButton() {
        const header = document.querySelector('.header');
        if (!header) return;

        const exportBtn = document.createElement('button');
        exportBtn.textContent = 'CSV ë‚´ë³´ë‚´ê¸°';
        exportBtn.style.marginTop = '10px';
        exportBtn.style.padding = '8px 14px';
        exportBtn.style.fontWeight = 'bold';
        exportBtn.style.borderRadius = '6px';
        exportBtn.style.border = 'none';
        exportBtn.style.cursor = 'pointer';
        exportBtn.style.background = '#3498db';
        exportBtn.style.color = '#fff';

        exportBtn.onclick = () => {
            const csv = generateCSV();
            if (!csv) {
            alert('ê¸°ë¡ëœ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.');
            return;
            }
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `damage_logs_${new Date().toISOString()}.csv`;
            link.click();
        };

        header.appendChild(exportBtn);
        }

        // CSV ë¬¸ìì—´ ìƒì„±
        function generateCSV() {
        const rows = [
            ['í”Œë ˆì´ì–´', 'ì‹œê°„', 'ìŠ¤í‚¬', 'ëŒ€ìƒ', 'ë°ë¯¸ì§€', 'í¬ë¦¬', 'ì¶”íƒ€', 'DOT', 'ì–¼ìŒ', 'ë¶ˆ', 'ì „ê¸°', 'ì‹ ì„±', 'ì¶œí˜ˆ', 'ë…', 'ì •ì‹ ']
        ];

        for (const [userId, data] of Object.entries(battleData)) {
            if (!data.damageLogs || data.damageLogs.length === 0) continue;

            for (const log of data.damageLogs) {
            const time = new Date(log.timestamp).toLocaleString('ko-KR');
            rows.push([
                userId,
                time,
                log.skill,
                log.target,
                log.damage,
                log.crit ? '1' : '0',
                log.addHit ? '1' : '0',
                log.dot ? '1' : '0',
                log.ice ? '1' : '0',
                log.fire ? '1' : '0',
                log.electric ? '1' : '0',
                log.holy ? '1' : '0',
                log.bleed ? '1' : '0',
                log.poison ? '1' : '0',
                log.mind ? '1' : '0'
            ]);
            }
        }

        if (rows.length === 1) return null; // Only header exists

        return rows.map(row => row.map(col => `"${col}"`).join(',')).join('\n');
        }

        // ì‹¤í–‰ ì‹œ ë²„íŠ¼ ì¶”ê°€
        addExportButton();
        // ì²´í¬ ìƒíƒœë¥¼ ì €ì¥í•˜ëŠ” ì „ì—­ ë³€ìˆ˜ ì¶”ê°€
        let pauseLogUpdate = false;
        // ì²´í¬ë°•ìŠ¤ ì¶”ê°€ í•¨ìˆ˜
        function addPauseCheckbox() {
        const header = document.querySelector('.header');
        if (!header) return;

        const pauseContainer = document.createElement('div');
        pauseContainer.style.marginTop = '10px';
        pauseContainer.style.display = 'flex';
        pauseContainer.style.alignItems = 'center';
        pauseContainer.style.gap = '8px';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = 'pause-log-update';
        checkbox.onchange = () => {
            pauseLogUpdate = checkbox.checked;
        };

        const label = document.createElement('label');
        label.htmlFor = 'pause-log-update';
        label.textContent = 'ë¡œê·¸ ê°±ì‹  ì¤‘ì§€';
        label.style.color = '#ecf0f1';
        label.style.fontSize = '0.95em';

        pauseContainer.appendChild(checkbox);
        pauseContainer.appendChild(label);
        header.appendChild(pauseContainer);
        }

        function updateDisplay() {
            if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                updateBattleInfo();
                return; // ì¸í’‹ ì¤‘ì—ëŠ” ìˆœìœ„ ê°±ì‹  ìƒëµ
            }
            updateBattleInfo();
            updatePlayerRankings();
        }
        // ê¸°ì¡´ updateDisplay í•¨ìˆ˜ ë‚´ë¶€ ìˆ˜ì •
        defaultUpdateDisplay = updateDisplay;
        updateDisplay = function() {
        if (pauseLogUpdate) {
            updateBattleInfo(); // ì‹œê°„, ì´í•©, DPS ë“±ì€ ìœ ì§€
            return;
        }
        defaultUpdateDisplay();
        }
        // ì²´í¬ë°•ìŠ¤ ì‹¤í–‰ ì‹œ ì¶”ê°€
        addPauseCheckbox();

        // Initialize
        connectWebSocket();
        setInterval(updateDisplay, 1000);
  </script>
</body>
</html>
